{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to TechLadies AFA's Coder Diary\n\n\nThis repository is a little documentation about our learning-journey when\ncreating the Asian Film Archive's submissions application as part of the\n\nTechLadies\n programme.\n\n\nHow to contribute to this diary\n\n\nWe are using \nMkDocs\n to create and organize this diary.\nFollow these steps to add entry:\n\n\n\n\nClone this repo to your local folder:\n\ngit clone https://github.com/TechLadies/afa-diary.git\n or if\nyou already have a clone, pull the latest changes: \ngit pull\n\n\nChange your directory to afa-diary: \ncd afa-diary\n\n\nCreate Virtualenv named mkdocs: \nmkvirtualenv mkdocs\n\n\nInstall MkDocs and other requirements using pip:\n\npip install -r requirements.txt\n\n\nAt this point, you can preview your local MkDocs site by running\nserver command: \nmkdocs server\n.\nYou should see something like this and then use browser to go to\n\nhttp://localhost:8000\n\n\n\n\n\n\n\n\nMake your changes locally and use localhost to preview the changes.\nRemember to add your page name and corresponding .md file to \nmkdocs.yml\n\n\nStage the changed files: \ngit add .\n\n\nCommit to git: \ngit commit -m \"Your descriptive message\"\n\n\nPush to Github repo: \ngit push -u origin master\n\n\n\n\nUseful pages for Markdown Syntax\n\n\n\n\nBasic writing and formatting syntax - Github\n\n\nCreating and highlighting code blocks - GitHub\n\n\nAdvanced formatting - Github", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-techladies-afas-coder-diary", 
            "text": "This repository is a little documentation about our learning-journey when\ncreating the Asian Film Archive's submissions application as part of the TechLadies  programme.", 
            "title": "Welcome to TechLadies AFA's Coder Diary"
        }, 
        {
            "location": "/#how-to-contribute-to-this-diary", 
            "text": "We are using  MkDocs  to create and organize this diary.\nFollow these steps to add entry:   Clone this repo to your local folder: git clone https://github.com/TechLadies/afa-diary.git  or if\nyou already have a clone, pull the latest changes:  git pull  Change your directory to afa-diary:  cd afa-diary  Create Virtualenv named mkdocs:  mkvirtualenv mkdocs  Install MkDocs and other requirements using pip: pip install -r requirements.txt  At this point, you can preview your local MkDocs site by running\nserver command:  mkdocs server .\nYou should see something like this and then use browser to go to http://localhost:8000     Make your changes locally and use localhost to preview the changes.\nRemember to add your page name and corresponding .md file to  mkdocs.yml  Stage the changed files:  git add .  Commit to git:  git commit -m \"Your descriptive message\"  Push to Github repo:  git push -u origin master", 
            "title": "How to contribute to this diary"
        }, 
        {
            "location": "/#useful-pages-for-markdown-syntax", 
            "text": "Basic writing and formatting syntax - Github  Creating and highlighting code blocks - GitHub  Advanced formatting - Github", 
            "title": "Useful pages for Markdown Syntax"
        }, 
        {
            "location": "/prerequisites/", 
            "text": "Setup Your Machine\n\n\nHere are list of applications required to setup development environment on Mac.\nIt's also recommended that you refer to our Glossary page\n\n\n1. iTerm2\n\n\nDownload iTerm2 from \nhttp://iterm2.com\n. Drag and drop the\napp into your Applications folder.\n\n\n2. ZSH\n\n\n\n\nOpen iTerm2 window.\n\n\nGo to \nhttp://ohmyz.sh\n, scroll down, copy and paste the\ninstallation line into iTerm2 window (we'll call this \nterminal\n).\n\n\nIf Zshell is not activated immediately, quit iTerm2 and open again.\n\n\n\n\n3. Homebrew\n\n\nGo to \nhttp://brew.sh\n, find, copy and paste the installation\nline into terminal.\n\n\nTo make sure it's installed properly, type \nwhich brew\n and it should reply\nyou with something like \n/usr/local/bin/brew\n\n\n4. Atom Editor\n\n\nDownload Atom from \nhttp://atom.io\n. Drag and drop the app into\nyour Applications folder.\nIf you start the editor on OSX for the first time, you should click at\n\"Atom \n Install Shell Commands\"\n\n\nOptionally, you can install these packages to help us deal with Python syntax:\n\n\n\n\nautocomplete-python\n\n\nlinter-flake8\n\n\n\n\nTo install Packages, press \n\u2318+,\n or from menu, \nAtom -\n Preferences\n.\nClick Install tab and search the package name, then click Install.\n\n\nClick Packages tab to show or remove packages installed. It's safe to try one package and remove it so don't worry about that.\n\n\n\n\n5. Git\n\n\nWe'll be using local git and Github.\n\n\n\n\n\n\nCheck if you already have git by typing \ngit\n in terminal. If you get a ton\nof output, you already have it. If not, install via Brew by typing\n\nbrew install git\n\n\n\n\n\n\nIf you're not familiar on how git works, a good interactive tutorial can be\nfound on\n\nhttps://try.github.io/levels/1/challenges/1\n\n\n\n\nCreate a profile on \nGitHub\n\n\n\n\n6. Slack\n\n\nTeam TechLadies uses \nSlack\n for daily communications and\nit has downloadable Mac app \nhere\n\n\n7. Python\n\n\nMac comes with Python. Try typing \npython --version\n into terminal and\nit will show you which version installed. Alternatively, you can also install\nvia Homebrew by typing \nbrew install python\n.\n\n\nThe difference is that if you install via Homebrew, the Python binary will be\nplaced under \n/usr/local/bin/python\n and it also automatically install \npip\n\nPython package manager.\n\n\nWe are using Python 2.7.11 for this project.\n\n\n8. Virtualenv \n virtualenvwrapper\n\n\nSteps to configure Virtualenv:\n\n\n\n\nFrom terminal, type \nsudo pip install virtualenv\n wait until completed.\n\n\nNext, type \nsudo pip install virtualenvwrapper\n wait until completed.\n\n\nNext, type \nexport WORKON_HOME=~/Envs\n. This will place all your virtualenv\nunder your \nHOME_DIRECTORY/Envs\n\n\nNext, type \necho 'export WORKON_HOME=~/Envs' \n ~/.zshrc\n\n\nNext, type \necho 'source /usr/local/bin/virtualenvwrapper.sh' \n ~/.zshrc\n\n\nNext, type \nmkdir -p $WORKON_HOME\n\n\nNext, type \nsource /usr/local/bin/virtualenvwrapper.sh\n\n\n\n\nTest virtualenv \n virtualenvwrapper\n\n\n\n\nOpen new terminal session and type \nmkvirtualenv myproject\n.\nIt should output few lines and the prompt on the left will indicate your\ncurrent active virtualenv which is \n(myproject)\n\n\nTo exit the virtualenv, type \ndeactivate\n, the prompt will go normal again.\n\n\nTo enter the virtualenv again, type \nworkon myproject\n.\n\n\nYou can create more virtualenv and to list all virtualenv you have,\ntype \nworkon\n only.\n\n\nTo delete a virtualenv, type \nrmvirtualenv myproject\n\n\n\n\n\n\nAny Python packages installed in this virtualenv only valid within this\nvirtualenv. To list the packages installed, type \npip freeze\n.\n\n\nAnd that's a wrap!\n\n\nLooks like we're good to go!", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/prerequisites/#setup-your-machine", 
            "text": "Here are list of applications required to setup development environment on Mac.\nIt's also recommended that you refer to our Glossary page", 
            "title": "Setup Your Machine"
        }, 
        {
            "location": "/prerequisites/#1-iterm2", 
            "text": "Download iTerm2 from  http://iterm2.com . Drag and drop the\napp into your Applications folder.", 
            "title": "1. iTerm2"
        }, 
        {
            "location": "/prerequisites/#2-zsh", 
            "text": "Open iTerm2 window.  Go to  http://ohmyz.sh , scroll down, copy and paste the\ninstallation line into iTerm2 window (we'll call this  terminal ).  If Zshell is not activated immediately, quit iTerm2 and open again.", 
            "title": "2. ZSH"
        }, 
        {
            "location": "/prerequisites/#3-homebrew", 
            "text": "Go to  http://brew.sh , find, copy and paste the installation\nline into terminal.  To make sure it's installed properly, type  which brew  and it should reply\nyou with something like  /usr/local/bin/brew", 
            "title": "3. Homebrew"
        }, 
        {
            "location": "/prerequisites/#4-atom-editor", 
            "text": "Download Atom from  http://atom.io . Drag and drop the app into\nyour Applications folder.\nIf you start the editor on OSX for the first time, you should click at\n\"Atom   Install Shell Commands\"  Optionally, you can install these packages to help us deal with Python syntax:   autocomplete-python  linter-flake8   To install Packages, press  \u2318+,  or from menu,  Atom -  Preferences .\nClick Install tab and search the package name, then click Install.  Click Packages tab to show or remove packages installed. It's safe to try one package and remove it so don't worry about that.", 
            "title": "4. Atom Editor"
        }, 
        {
            "location": "/prerequisites/#5-git", 
            "text": "We'll be using local git and Github.    Check if you already have git by typing  git  in terminal. If you get a ton\nof output, you already have it. If not, install via Brew by typing brew install git    If you're not familiar on how git works, a good interactive tutorial can be\nfound on https://try.github.io/levels/1/challenges/1   Create a profile on  GitHub", 
            "title": "5. Git"
        }, 
        {
            "location": "/prerequisites/#6-slack", 
            "text": "Team TechLadies uses  Slack  for daily communications and\nit has downloadable Mac app  here", 
            "title": "6. Slack"
        }, 
        {
            "location": "/prerequisites/#7-python", 
            "text": "Mac comes with Python. Try typing  python --version  into terminal and\nit will show you which version installed. Alternatively, you can also install\nvia Homebrew by typing  brew install python .  The difference is that if you install via Homebrew, the Python binary will be\nplaced under  /usr/local/bin/python  and it also automatically install  pip \nPython package manager.  We are using Python 2.7.11 for this project.", 
            "title": "7. Python"
        }, 
        {
            "location": "/prerequisites/#8-virtualenv-virtualenvwrapper", 
            "text": "Steps to configure Virtualenv:   From terminal, type  sudo pip install virtualenv  wait until completed.  Next, type  sudo pip install virtualenvwrapper  wait until completed.  Next, type  export WORKON_HOME=~/Envs . This will place all your virtualenv\nunder your  HOME_DIRECTORY/Envs  Next, type  echo 'export WORKON_HOME=~/Envs'   ~/.zshrc  Next, type  echo 'source /usr/local/bin/virtualenvwrapper.sh'   ~/.zshrc  Next, type  mkdir -p $WORKON_HOME  Next, type  source /usr/local/bin/virtualenvwrapper.sh   Test virtualenv   virtualenvwrapper   Open new terminal session and type  mkvirtualenv myproject .\nIt should output few lines and the prompt on the left will indicate your\ncurrent active virtualenv which is  (myproject)  To exit the virtualenv, type  deactivate , the prompt will go normal again.  To enter the virtualenv again, type  workon myproject .  You can create more virtualenv and to list all virtualenv you have,\ntype  workon  only.  To delete a virtualenv, type  rmvirtualenv myproject    Any Python packages installed in this virtualenv only valid within this\nvirtualenv. To list the packages installed, type  pip freeze .", 
            "title": "8. Virtualenv &amp; virtualenvwrapper"
        }, 
        {
            "location": "/prerequisites/#and-thats-a-wrap", 
            "text": "Looks like we're good to go!", 
            "title": "And that's a wrap!"
        }, 
        {
            "location": "/project/git/", 
            "text": "Git\n\n\nWe are using \nGit\n as our version control system and\n\nGitHub\n for hosting our repositories and for collaboration.\n\n\nTutorials\n\n\nTo learn the basics of Git we worked through the following tutorials:\n\n\n\n\nhttps://try.github.io\n\n\nhttps://guides.github.com/activities/hello-world/\n\n\nhttps://github.com/git-game/git-game\n\n\n\n\nWe also participated in a three-hour workshop conducted by the organizers of\nthe \nGrumpy Gits SG User Group\n.\n\n\nWarning\n: Learning Git on your own is a difficult task, because there are\nmany different commands that you need to memorize. To make things worse, there\nis one command called \"checkout\" that does at least three completely different\nthings and some of those things don't even have anything to do with \"checking\nsomething out.\n\n\nThere are also dozens of ways to orchestrate all those many commands. Basically\nevery company out there has their own internal workflow, therefore you will not\nfind the one definite tutorial that teaches you how to do it and if you ask\nquestions, three people will give you three different answers.\n\n\nYou should definitely team up with a mentor who can guide you and work through a\nfew test-scenarios with you and ultimately you need to understand what Git is\ndoing on your hard disk in order to really have confidence in whatever workflow\nyou decided to use.\n\n\nWorkflow\n\n\nIn order to collaborate on this repository, we will stick to a simplified\nworkflow that has only the \nmaster\n branch as a stable branch.\n\n\nThis means, whatever we merge into \nmaster\n should be good. At all times must we\nbe confident that the \nmaster\n branch can be deployed by using the\n\nmkdocs gh-deploy\n command.\n\n\nIn plain English, our workflow works as follows: When you decide to create a\nchange, you first pull the latest version of the \nmaster\n branch from GitHub.\nThen you create a feature branch and make your changes. When you are done, you\npush your feature branch to GitHub so that the team can make a code-review.\n\n\n\n\ngit co master\n (switch to master branch)\n\n\ngit pull\n (get the latest version of the master branch)\n\n\ngit co -b feature_branch\n (create your own feature branch)\n\n\nwork work work work work work\n\n\ngit add .\n (add your changes to the staging area)\n\n\ngit commit\n (commit your changes)\n\n\ngit push origin feature_branch\n (push your feature branch to GitHub)\n\n\n\n\nYour mentor will usually do this, but for the sake of completeness, here is how\nwe merge your changes back into the \nmaster\n branch when you have passed the\ncode-review:\n\n\nFirst we pull the latest \nmaster\n branch just to be sure that we are up to\ndate. Then we go into the feature branch and try to merge the \nmaster\n branch\ninto the feature branch. We do this because other team members might have\npushed to the \nmaster\n branch while you were working on your feature and there\nmight be merge conflicts if both members worked on the same files. We want to\nresolve those conflicts in the feature branch, just to be sure that we don't\naccidentally mess up the master branch during the conflict resolution.\n\n\nMost of the time, there won't be any conflicts. In that case, we will switch\nback into the \nmaster\n branch and then merge the feature branch with the\n\n--no-ff\n flag into the \nmaster\n branch. The \n--no-ff\n makes sure that we can\nsee \"a bump\" in the diagram view of our repository, so in the future we can\nstill tell that a bunch of commits have all been made inside a certain\nfeature branch. Once the feature branch has been merged into the master branch,\nit can be deleted locally and on GitHub.\n\n\n\n\ngit co master\n (switch to master branch)\n\n\ngit pull\n (get latest version of master branch)\n\n\ngit co feature_branch\n (switch to feature branch)\n\n\ngit merge master\n (resolve merge conflicts, if any)\n\n\ngit co master\n (switch back to master branch)\n\n\ngit merge --no-ff feature_branch\n (merge the feature branch)\n\n\ngit push\n (push new master branch to GitHub)\n\n\ngit branch -d feature_branch\n (delete the feature branch locally)\n\n\ngit push origin :feature_branch\n (delete feature branch on GitHub)", 
            "title": "Git"
        }, 
        {
            "location": "/project/git/#git", 
            "text": "We are using  Git  as our version control system and GitHub  for hosting our repositories and for collaboration.", 
            "title": "Git"
        }, 
        {
            "location": "/project/git/#tutorials", 
            "text": "To learn the basics of Git we worked through the following tutorials:   https://try.github.io  https://guides.github.com/activities/hello-world/  https://github.com/git-game/git-game   We also participated in a three-hour workshop conducted by the organizers of\nthe  Grumpy Gits SG User Group .  Warning : Learning Git on your own is a difficult task, because there are\nmany different commands that you need to memorize. To make things worse, there\nis one command called \"checkout\" that does at least three completely different\nthings and some of those things don't even have anything to do with \"checking\nsomething out.  There are also dozens of ways to orchestrate all those many commands. Basically\nevery company out there has their own internal workflow, therefore you will not\nfind the one definite tutorial that teaches you how to do it and if you ask\nquestions, three people will give you three different answers.  You should definitely team up with a mentor who can guide you and work through a\nfew test-scenarios with you and ultimately you need to understand what Git is\ndoing on your hard disk in order to really have confidence in whatever workflow\nyou decided to use.", 
            "title": "Tutorials"
        }, 
        {
            "location": "/project/git/#workflow", 
            "text": "In order to collaborate on this repository, we will stick to a simplified\nworkflow that has only the  master  branch as a stable branch.  This means, whatever we merge into  master  should be good. At all times must we\nbe confident that the  master  branch can be deployed by using the mkdocs gh-deploy  command.  In plain English, our workflow works as follows: When you decide to create a\nchange, you first pull the latest version of the  master  branch from GitHub.\nThen you create a feature branch and make your changes. When you are done, you\npush your feature branch to GitHub so that the team can make a code-review.   git co master  (switch to master branch)  git pull  (get the latest version of the master branch)  git co -b feature_branch  (create your own feature branch)  work work work work work work  git add .  (add your changes to the staging area)  git commit  (commit your changes)  git push origin feature_branch  (push your feature branch to GitHub)   Your mentor will usually do this, but for the sake of completeness, here is how\nwe merge your changes back into the  master  branch when you have passed the\ncode-review:  First we pull the latest  master  branch just to be sure that we are up to\ndate. Then we go into the feature branch and try to merge the  master  branch\ninto the feature branch. We do this because other team members might have\npushed to the  master  branch while you were working on your feature and there\nmight be merge conflicts if both members worked on the same files. We want to\nresolve those conflicts in the feature branch, just to be sure that we don't\naccidentally mess up the master branch during the conflict resolution.  Most of the time, there won't be any conflicts. In that case, we will switch\nback into the  master  branch and then merge the feature branch with the --no-ff  flag into the  master  branch. The  --no-ff  makes sure that we can\nsee \"a bump\" in the diagram view of our repository, so in the future we can\nstill tell that a bunch of commits have all been made inside a certain\nfeature branch. Once the feature branch has been merged into the master branch,\nit can be deleted locally and on GitHub.   git co master  (switch to master branch)  git pull  (get latest version of master branch)  git co feature_branch  (switch to feature branch)  git merge master  (resolve merge conflicts, if any)  git co master  (switch back to master branch)  git merge --no-ff feature_branch  (merge the feature branch)  git push  (push new master branch to GitHub)  git branch -d feature_branch  (delete the feature branch locally)  git push origin :feature_branch  (delete feature branch on GitHub)", 
            "title": "Workflow"
        }, 
        {
            "location": "/project/ansible/", 
            "text": "", 
            "title": "Ansible"
        }, 
        {
            "location": "/project/django/", 
            "text": "", 
            "title": "Django"
        }, 
        {
            "location": "/project/html/", 
            "text": "", 
            "title": "HTML / CSS"
        }, 
        {
            "location": "/glossary/", 
            "text": "Glossary\n\n\nDuring our journey of learning how to build a full-stack Django project,\nwe will learn many new technical terms. We will try to keep track of them\nin this glossary.\n\n\nAnsible\n\n\nAnsible is a tool to \"provision\" servers. That means it helps to install\nsoftware on a server in an automated, scripted and repeatable way.\n\n\nBranch\n\n\nA branch is the parallel version of the Master Branch (See also: Master Branch). The Master Branch is copied and branched out into a branch. Work on or modify the code here, as changes will not affect the main repository. Branches can also be used for bug fixing, as the work here does not affect the main repository until merged and committed. Merge the branch into the Master Branch only after all changes are made and it is ready to publish.\n\n\nThere can be several branches in a repository. Branches can be deleted after the merge is complete. Branches can also be referred to as volatile branches.\n\n\nThe command to create a new branch is \ngit branch new_branch name\n. Check existing branches and which branch you are currently on by using the command \ngit branch\n. The branch you are currently on will be indicated by an asterisk before its name.\n\n\nClone\n\n\nA clone is a copy of a repository that lives on your local computer once copied from a remote server. The command to clone a remote server is \ngit clone [url of server]\n. Changes have to be pushed (See also: Push) onto the remote server, to be able to see them on the remote server.\n\n\nCheckout\n\n\nCheckout in Git is tricky, as it serves multiple uses.\n\n\nOne use is to switch from to a branch, as seen in \ngit checkout branch_name\n. Create a new branch and checkout to it at the same time by using the command \ngit checkout -b new_branch_name\n.\n\n\nCheckout can also be used to return the file to a previous version. \ngit checkout \ncommit\n returns the file to the version of the particular commit. \n is the first 7 character of your commit hash (See also: Hash), which helps to identity which particular commit it is.\n\n\nCommit\n\n\nCommit is the action to apply your changed and staged files. To make a commit\ntype \ngit commit -m \"Description about your commit\"\n\n\nDjango\n\n\nDjango is a high-level Python Web framework that encourages rapid development\nand clean, pragmatic design. It's free and open source.\n\n\nDroplet\n\n\nDroplet refers to a virtual private server instance at DigitalOcean that is\nsetup and can be configured to user's need such as CPU size, memory, hard disk\ncapacity, installed OS, and more.\n\n\nFull Stack\n\n\nA web application consists of many layers for instance: user interface, business\nlogic, servers, databases, operating systems. Each layer has different\ntechnology which is what we call a \nstack\n. This entire web application is\ntherefore called Full Stack.\n\n\nGit\n\n\nGit is a version control system. You can turn a normal folder on your hard disk\ninto a \"repository\". When you do that, Git will keep track of all changes made\nto all files. You can then \"commit\" your changes and review them in a log or\neven go back to an older version of your files. When working on a project with\na team, this helps to keep track about who did what and when.\n\n\nHash\n\n\nA hash is a unique ID that is generated with each commit.\n\n\nMaster Branch\n\n\nMaster branches are stable branches. These are the ones to be shared amongst collaborators of a project, which ought to stay the way they are. Any modifications should go into volatile branches (See also: Branch) to avoid affecting the repository.\n\n\nMerge\n\n\nMerge is git action of joining two or more development histories together.\n\n\nPull\n\n\nPull is to extract the latest version of the master branch and other branches from Git so that the user can work off the latest version of a repository.\n\n\nPush\n\n\nWhen a user is done with making changes to their branch they can \"push\" their changes to the master. By doing so, they update the master with the changes that they have committed.\n\n\nRebase\n\n\nRebasing is the process of moving a branch to a new base commit.\nFrom a content perspective, rebasing really is just moving a branch from one\ncommit to another. But internally, Git accomplishes this by creating new\ncommits and applying them to the specified base\u2014it\u2019s literally rewriting\nyour project history.\n\n\nRepository\n\n\nRepository is where git stores information about a project files and its\nhistory.\n\n\nStaged\n\n\nWhen a user has made changes to a repository they can add those changes. By doing so the user \"stages\" their changes. Only staged changes can be committed.\n\n\nTerminal\n\n\nThe Terminal is the part of the computer where programmers can program information and data into the computer.", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#glossary", 
            "text": "During our journey of learning how to build a full-stack Django project,\nwe will learn many new technical terms. We will try to keep track of them\nin this glossary.  Ansible  Ansible is a tool to \"provision\" servers. That means it helps to install\nsoftware on a server in an automated, scripted and repeatable way.  Branch  A branch is the parallel version of the Master Branch (See also: Master Branch). The Master Branch is copied and branched out into a branch. Work on or modify the code here, as changes will not affect the main repository. Branches can also be used for bug fixing, as the work here does not affect the main repository until merged and committed. Merge the branch into the Master Branch only after all changes are made and it is ready to publish.  There can be several branches in a repository. Branches can be deleted after the merge is complete. Branches can also be referred to as volatile branches.  The command to create a new branch is  git branch new_branch name . Check existing branches and which branch you are currently on by using the command  git branch . The branch you are currently on will be indicated by an asterisk before its name.  Clone  A clone is a copy of a repository that lives on your local computer once copied from a remote server. The command to clone a remote server is  git clone [url of server] . Changes have to be pushed (See also: Push) onto the remote server, to be able to see them on the remote server.  Checkout  Checkout in Git is tricky, as it serves multiple uses.  One use is to switch from to a branch, as seen in  git checkout branch_name . Create a new branch and checkout to it at the same time by using the command  git checkout -b new_branch_name .  Checkout can also be used to return the file to a previous version.  git checkout  commit  returns the file to the version of the particular commit.   is the first 7 character of your commit hash (See also: Hash), which helps to identity which particular commit it is.  Commit  Commit is the action to apply your changed and staged files. To make a commit\ntype  git commit -m \"Description about your commit\"  Django  Django is a high-level Python Web framework that encourages rapid development\nand clean, pragmatic design. It's free and open source.  Droplet  Droplet refers to a virtual private server instance at DigitalOcean that is\nsetup and can be configured to user's need such as CPU size, memory, hard disk\ncapacity, installed OS, and more.  Full Stack  A web application consists of many layers for instance: user interface, business\nlogic, servers, databases, operating systems. Each layer has different\ntechnology which is what we call a  stack . This entire web application is\ntherefore called Full Stack.  Git  Git is a version control system. You can turn a normal folder on your hard disk\ninto a \"repository\". When you do that, Git will keep track of all changes made\nto all files. You can then \"commit\" your changes and review them in a log or\neven go back to an older version of your files. When working on a project with\na team, this helps to keep track about who did what and when.  Hash  A hash is a unique ID that is generated with each commit.  Master Branch  Master branches are stable branches. These are the ones to be shared amongst collaborators of a project, which ought to stay the way they are. Any modifications should go into volatile branches (See also: Branch) to avoid affecting the repository.  Merge  Merge is git action of joining two or more development histories together.  Pull  Pull is to extract the latest version of the master branch and other branches from Git so that the user can work off the latest version of a repository.  Push  When a user is done with making changes to their branch they can \"push\" their changes to the master. By doing so, they update the master with the changes that they have committed.  Rebase  Rebasing is the process of moving a branch to a new base commit.\nFrom a content perspective, rebasing really is just moving a branch from one\ncommit to another. But internally, Git accomplishes this by creating new\ncommits and applying them to the specified base\u2014it\u2019s literally rewriting\nyour project history.  Repository  Repository is where git stores information about a project files and its\nhistory.  Staged  When a user has made changes to a repository they can add those changes. By doing so the user \"stages\" their changes. Only staged changes can be committed.  Terminal  The Terminal is the part of the computer where programmers can program information and data into the computer.", 
            "title": "Glossary"
        }
    ]
}